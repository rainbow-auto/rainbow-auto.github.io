<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="rainbow-auto">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://rainbow-auto.github.io/2023/10/02/蒟蒻の模板/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="蒟蒻 Rainbow-Automaton 的模板$\text{2023-10}$ 备战 $\text{csp-s}$ 只是目前会的 然而目前啥也不会… 代码注意事项 不要使用using namespace std;  min 和 max 都可以直接 std::min std::max 吧  关同步 #define fastread std::ios_sync_with_stdio (false);">
<meta property="og:type" content="article">
<meta property="og:title" content="蒟蒻の模板">
<meta property="og:url" content="https://rainbow-auto.github.io/2023/10/02/%E8%92%9F%E8%92%BB%E3%81%AE%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="Rainbow-Automaton&#39;s blog">
<meta property="og:description" content="蒟蒻 Rainbow-Automaton 的模板$\text{2023-10}$ 备战 $\text{csp-s}$ 只是目前会的 然而目前啥也不会… 代码注意事项 不要使用using namespace std;  min 和 max 都可以直接 std::min std::max 吧  关同步 #define fastread std::ios_sync_with_stdio (false);">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-02T14:01:54.000Z">
<meta property="article:modified_time" content="2024-08-26T14:03:18.753Z">
<meta property="article:author" content="rainbow-auto">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            蒟蒻の模板 -
        
        Rainbow-Automaton&#39;s blog
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    

    
        
<script src="/js/libs/anime.min.js"></script>

    

    <script id="hexo-configurations">
    window.config = {"hostname":"rainbow-auto.github.io","root":"/","language":"zh-CN","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"雲のようにそっとそっと","subtitle":{"text":["どこまでもずっとずっと前へ"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":false,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/rainbow-auto","instagram":null,"zhihu":"https://www.zhihu.com/people/rainbow-auto","twitter":null,"email":"caotianlang@outlook.com","fa-solid fa-code":"https://www.luogu.com.cn/user/374258"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.4","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/8/26 17:20:00"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>



    <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    <h2 class="ml13">
        Rainbow-Automaton&#39;s blog
    </h2>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [40,0],
                translateZ: 0,
                opacity: [0,1],
                filter: ['blur(5px)', 'blur(0px)'], // Starting from blurred to unblurred
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i,
            }).add({
                targets: '.ml13 .letter',
                translateY: [0,-40],
                opacity: [1,0],
                filter: ['blur(0px)', 'blur(5px)'], // Ending from unblurred to blurred
                easing: "easeInExpo",
                duration: 1200,
                delay: (el, i) => 100 + 30 * i,
                complete: function() {
                    hidePreloader(); // Call hidePreloader after the animation completes
                }
            });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }
    </script>
</div>

<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Rainbow-Automaton&#39;s blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">1</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">蒟蒻の模板</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/redefine-avatar.svg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">rainbow-auto</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-10-02 22:01:54</span>
        <span class="mobile">2023-10-02 22:01:54</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-08-26 22:03:18</span>
            <span class="mobile">2024-08-26 22:03:18</span>
            <span class="hover-info">更新</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h1 id="蒟蒻-Rainbow-Automaton-的模板"><a href="#蒟蒻-Rainbow-Automaton-的模板" class="headerlink" title="蒟蒻 Rainbow-Automaton 的模板"></a>蒟蒻 Rainbow-Automaton 的模板</h1><p>$\text{2023-10}$ 备战 $\text{csp-s}$</p>
<p>只是目前会的</p>
<p><del>然而目前啥也不会…</del></p>
<h2 id="代码注意事项"><a href="#代码注意事项" class="headerlink" title="代码注意事项"></a>代码注意事项</h2><ul>
<li><p><strong>不要使用<code>using namespace std;</code></strong></p>
</li>
<li><p><code>min</code> 和 <code>max</code> 都可以直接 <code>std::min</code> <code>std::max</code> 吧</p>
</li>
<li><p>关同步 <code>#define fastread std::ios_sync_with_stdio (false); cin.tie (0);</code></p>
</li>
<li><p>学习 jiangly <code>using i64 = long long</code></p>
</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="对拍"><a href="#对拍" class="headerlink" title="对拍"></a>对拍</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">pai</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Generate</span></span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;gen.exe &gt; test.in&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// display ();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run</span></span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;test_1.exe &lt; test.in &gt; test_1.out&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;test_2.exe &lt; test.in &gt; test_2.out&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">system</span> (<span class="string">&quot;fc test_1.out test_2.out&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="毫秒级随机数"><a href="#毫秒级随机数" class="headerlink" title="毫秒级随机数"></a>毫秒级随机数</h3><p>通常作为对拍时的随机数生成器</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now ().time_since_epoch ().count ())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getRand</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt; (l, r) (rng);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h3><p>防止 TLE</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getTime</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;gen.exe &gt; test.in&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> s = std::chrono::steady_clock::<span class="built_in">now</span> ();</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;test_2.exe &lt; test.in &gt; test_2.out&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> t = std::chrono::steady_clock::<span class="built_in">now</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::duration_cast &lt;std::chrono::microseconds&gt; (t - s); </span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> cost = (<span class="type">double</span>) duration.<span class="built_in">count</span> () / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; cost &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h3><p><del>这种东西真的需要记吗</del></p>
<p>写一个神秘的封装好的图</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> maxn, <span class="type">int</span> maxm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="type">int</span> pre;</span><br><span class="line">    &#125; es[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last[maxn], cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span> () &#123; cnt = <span class="number">0</span>; <span class="built_in">memset</span> (last, <span class="number">0</span>, <span class="built_in">sizeof</span> (last)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        es[++cnt] = Edge &#123; u, v, last[u] &#125;;</span><br><span class="line">        last[u] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>然而我大部分时侯都不会用到封装好的图…</p>
<p>一般情况下只会直接写 <code>Graph</code> 里面的东西</p>
<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> dis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Node a, Node b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.dis &gt; b.dis; <span class="comment">// 通过改符号的方向实现小根堆...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dij</span> <span class="params">(<span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (vis, <span class="number">0</span>, <span class="built_in">sizeof</span> (vis));</span><br><span class="line">    <span class="built_in">memset</span> (dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span> (dis)); dis[S] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span> (Node &#123; S, dis[S] &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span> q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">top</span> ().id; q.<span class="built_in">pop</span> ();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis[now]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">            <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dis[t] &gt; dis[now] + es[i].w) &#123;</span><br><span class="line">                dis[t] = dis[now] + es[i].w;</span><br><span class="line">                q.<span class="built_in">push</span> (Node &#123; t, dis[t] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="某个广为人所知的最短路算法"><a href="#某个广为人所知的最短路算法" class="headerlink" title="某个广为人所知的最短路算法"></a>某个广为人所知的最短路算法</h4><p>判负环</p>
<p>不判负环最好别用</p>
<p><del>才发现我单源最短路都是用 Dijkstra 过的</del></p>
<p><del>甚至找不到一个SPFA的板子</del></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> inq[maxn];</span><br><span class="line"><span class="type">int</span> times[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">spfa</span> <span class="params">(<span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span> (S);</span><br><span class="line">    <span class="built_in">memset</span> (inq, <span class="number">0</span>, <span class="built_in">sizeof</span> (inq)); inq[S] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memset</span> (times, <span class="number">0</span>, <span class="built_in">sizeof</span> (times)); times[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123; <span class="keyword">if</span> (i != S) &#123; dis[i] = inf; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span> q.<span class="built_in">empty</span> ()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span> (); q.<span class="built_in">pop</span> ();</span><br><span class="line">        inq[now] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">            <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dis[t] &gt; dis[now] + es[i].w) &#123;</span><br><span class="line">                dis[t] = dis[now] + es[i].w;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> inq[t]) &#123;</span><br><span class="line">                    inq[t] = <span class="literal">true</span>;</span><br><span class="line">                    times[t] ++; <span class="keyword">if</span> (times[t] &gt; n + <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">// 此处n + 1是因为多了一个超级源</span></span><br><span class="line"></span><br><span class="line">                    q.<span class="built_in">push</span> (t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h5><p><del>也许是唯一能用上SPFA的地方吧…</del></p>
<p>可以解出 $m$ 个形如 $X_u - X_v \leq Y$ 的不等式组成的不等式组的一个解</p>
<p><del>自然也可以判断是否有解</del></p>
<p>实质就是 $u - v \leq w \implies u \leq v + w \implies Edge_{v, u, w} $</p>
<p>$v$ 到 $u$ 连一条长度为 $w$ 的边</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">diff_constraints</span> <span class="params">()</span> </span>&#123; <span class="comment">// 差分约束</span></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">addEdge</span> (v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以n + 1作为超级源点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="built_in">addEdge</span> (n + <span class="number">1</span>, i, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">spfa</span> (n + <span class="number">1</span>)) &#123; std::cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; std::cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></div>

<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span> (dis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; dis[i][i] = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">floyd</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dis[i][j] = std::<span class="built_in">min</span> (dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意先 <code>init()</code> 再加边</p>
<h5 id="倍增Floyd"><a href="#倍增Floyd" class="headerlink" title="倍增Floyd"></a>倍增Floyd</h5><p>实际上是矩阵快速幂</p>
<p>把 $\text{Floyd}$ 原来的用 $dp[k][i][j]$ 表示前 $k$ 个点中 $i$ 到 $j$ 的最短路</p>
<p>改为用 $dp[s][i][j]$ 表示长度为 $s$ 的 $i$ 到 $j$ 的最短路</p>
<p>显然</p>
<p>$dp[s][i][j]$ 可以由 $ \min\limits_{k &#x3D; 1}^{n} {dp[s - 1][i][k] + dp[1][k][j]}$ 转移过来</p>
<p>然后我们发现转移的过程和矩阵乘法特别像</p>
<p>用快速幂求出 $dp^k$ 就可以得到长为 $k$ 的路径条数</p>
<h5 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h5><p>实际上就是 $01$ 矩阵上的 $\text{Floyd}$</p>
<p>只是求最短路改成求连通性了</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;maxn&gt; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">floydClosure</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j]) &#123; <span class="comment">// i 能到 j</span></span><br><span class="line">                a[i] |= a[j]; <span class="comment">// 用j更新i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>上面的代码是用 <code>bitset</code> 写的, 与传统 $\text{Floyd}$ 略有不同</p>
<p>但是其基本思想是类似的</p>
</blockquote>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Edge a, Edge b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; es;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">kruskal</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span> (es.<span class="built_in">begin</span> (), es.<span class="built_in">end</span> ());</span><br><span class="line">    <span class="built_in">init</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : es) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span> (e.u);</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">find</span> (e.v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        fa[u] = v;</span><br><span class="line">        ans += e.w;</span><br><span class="line"></span><br><span class="line">        tot ++;</span><br><span class="line">        <span class="keyword">if</span> (tot == n - <span class="number">1</span>) &#123; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>其中 <code>init()</code> 就是并查集的 <code>init()</code></p>
<p>并查集的写法看数据结构部分吧</p>
</blockquote>
<h3 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h3><p>一定要加当前弧优化!</p>
<p>否则复杂度其实是假的</p>
<p><del>依然记得在mx想出正解但是欧拉回路写挂了</del></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; g[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ind[maxn], otd[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[maxn];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; euler;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> eid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = st[now]; i &lt; g[now].<span class="built_in">size</span> (); i = st[now]) &#123; <span class="comment">// g[now] 中编号一定是单增的</span></span><br><span class="line">        st[now] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = g[now][i];</span><br><span class="line">        <span class="built_in">dfs</span> (es[t].v, t);</span><br><span class="line">    &#125;</span><br><span class="line">    euler.<span class="built_in">push_back</span> (eid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>upd: 换一个更人性的写法</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::vector &lt;<span class="type">int</span>&gt; g[maxn];</span><br><span class="line"><span class="type">int</span> ind[maxn], otd[maxn];</span><br><span class="line"></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; euler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">db</span> (now);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">not</span> g[now].<span class="built_in">empty</span> ()) &#123;</span><br><span class="line">		<span class="type">int</span> t = g[now].<span class="built_in">back</span> ();</span><br><span class="line">		g[now].<span class="built_in">pop_back</span> (); <span class="comment">// 自带当前弧优化</span></span><br><span class="line">		<span class="built_in">dfs</span> (t);</span><br><span class="line">	&#125;</span><br><span class="line">    euler.<span class="built_in">push_back</span> (now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>upd: 判断</p>
<ul>
<li><p>有向图欧拉路径的判断</p>
  <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dcnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dcnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] - otd[i] == <span class="number">0</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ind[i] - otd[i] == <span class="number">1</span>) &#123; dcnt1 ++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ind[i] - otd[i] == <span class="number">-1</span>) &#123; dcnt2 ++; start = i; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dcnt1 &gt; <span class="number">1</span> <span class="keyword">or</span> dcnt2 &gt; <span class="number">1</span> <span class="keyword">or</span> dcnt1 + dcnt2 == <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>判断是否存在无向图欧拉回路 : 是否所有点入度等于出度</p>
</li>
</ul>
<p>最后记得判断求出来的长度是否合法</p>
<h3 id="Tarjan-系列"><a href="#Tarjan-系列" class="headerlink" title="Tarjan 系列"></a>Tarjan 系列</h3><h4 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h4><p>对于一个有向图, 一个强连通分量 $S$ 是指极大的保证 $\forall u, v \in S$ 存在 $u \to v$ 的路径 和 $v \to u$ 的路径的点集</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low[maxn], dfn[maxn], dpos;</span><br><span class="line"><span class="type">int</span> stk[maxn], spos;</span><br><span class="line"><span class="type">bool</span> ins[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> belong[maxn], scc_cnt;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; scc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    low[now] = dfn[now] = ++dpos;</span><br><span class="line">    stk[++spos] = now;</span><br><span class="line">    ins[now] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">        <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> dfn[t]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span> (t);</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], low[t]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[t]) &#123;</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], dfn[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low[now] == dfn[now]) &#123;</span><br><span class="line">        scc_cnt ++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            belong[now] = scc_cnt;</span><br><span class="line">            scc[scc_cnt].<span class="built_in">insert</span> (now);</span><br><span class="line">            ins[now] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            now = stk[spos--];</span><br><span class="line">        &#125; <span class="keyword">while</span> (low[now] != dfn[now]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h5><p>用 $1$ 到 $n$ 表示 $a_i$ 取 $0$</p>
<p>用 $n + 1$ 到 $2 \times n$ 表示 $a_{i - n}$ 取 $1$</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> dfn[i]) &#123; <span class="built_in">tarjan</span> (i); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">check</span> ()) &#123; std::cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;POSSIBLE&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scc[i + n] &lt; scc[i]) &#123; std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; std::cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low[maxn], dfn[maxn], dpos;</span><br><span class="line"><span class="type">bool</span> cut[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    low[now] = dfn[now] = ++dpos;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sons = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">        <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> dfn[t]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span> (t, now);</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], low[t]);</span><br><span class="line">            sons ++;</span><br><span class="line">            <span class="keyword">if</span> (low[t] &gt;= dfn[now]) &#123; cut[now] = <span class="literal">true</span>; &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此处可以考虑父亲</span></span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], dfn[t]);</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fa == <span class="number">0</span> <span class="keyword">and</span> sons &lt; <span class="number">2</span>) &#123; cut[now] = <span class="literal">false</span>; &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h5 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h5><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low[maxn], dfn[maxn], dpos;</span><br><span class="line"><span class="type">int</span> stk[maxn], spos;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> belong[maxn], vdcc_cnt;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vdcc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    low[now] = dfn[now] = ++dpos;</span><br><span class="line">    stk[++spos] = now;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sons = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">        <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> dfn[t]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span> (t, now);</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], low[t]);</span><br><span class="line"></span><br><span class="line">            sons ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (low[t] &gt;= dfn[now]) &#123;</span><br><span class="line">                ++vdcc_cnt;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (last != t) &#123;</span><br><span class="line">                    <span class="type">int</span> top = stk[spos--];</span><br><span class="line">                    belong[top] = vdcc_cnt;</span><br><span class="line">                    vdcc[vdcc_cnt].<span class="built_in">push_back</span> (top);         </span><br><span class="line">                    last = top;</span><br><span class="line">                &#125;</span><br><span class="line">                vdcc[vdcc_cnt].<span class="built_in">push_back</span> (now);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], dfn[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fa == <span class="number">0</span> <span class="keyword">and</span> sons == <span class="number">0</span>) &#123; vdcc_cnt ++; vdcc[vdcc_cnt].<span class="built_in">push_back</span> (now); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low[maxn], dfn[maxn], dpos;</span><br><span class="line"><span class="type">bool</span> bridge[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> in_edge)</span> </span>&#123;</span><br><span class="line">    low[now] = dfn[now] = ++dpos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">        <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> dfn[t]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span> (t, i);</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], low[t]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (low[t] &gt; dfn[now]) &#123; bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != (in_edge ^ <span class="number">1</span>)) &#123;</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], dfn[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123; cnt = <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>因为涉及到快速找反向边, <strong>一定要把 <code>cnt</code> 初始化为1!</strong></p>
</blockquote>
<h5 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h5><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low[maxn], dfn[maxn], dpos;</span><br><span class="line"><span class="type">bool</span> bridge[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> in_edge)</span> </span>&#123;</span><br><span class="line">    low[now] = dfn[now] = ++dpos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">        <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> dfn[t]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span> (t, i);</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], low[t]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (low[t] &gt; dfn[now]) &#123; bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != (in_edge ^ <span class="number">1</span>)) &#123;</span><br><span class="line">            low[now] = std::<span class="built_in">min</span> (low[now], dfn[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> belong[maxn], edcc_cnt;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; edcc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    belong[now] = edcc_cnt;</span><br><span class="line">    edcc[edcc_cnt].<span class="built_in">push_back</span> (now);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">        <span class="type">int</span> t = es[i].v;</span><br><span class="line">        <span class="keyword">if</span> (bridge[i]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (belong[t]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span> (t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123; cnt = <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><blockquote>
<p>网络流的加边方式与普通图论问题的加边方式略有不同</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">   <span class="type">int</span> u, v;</span><br><span class="line">   <span class="type">int</span> pre;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> flow;</span><br><span class="line">&#125; es[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> last[maxn], cur[maxn], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _addEdge (<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">long</span> <span class="type">long</span> cap) &#123;</span><br><span class="line">   es[++cnt] = Edge &#123; u, v, last[u], cap &#125;;</span><br><span class="line">   last[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">long</span> <span class="type">long</span> cap)</span> </span>&#123;</span><br><span class="line">   _addEdge (u, v, cap);</span><br><span class="line">   _addEdge (v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dep[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span> (S);</span><br><span class="line">    <span class="built_in">memset</span> (dep, <span class="number">0x3f</span>, <span class="built_in">sizeof</span> (dep)); dep[S] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span> q.<span class="built_in">empty</span> ()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span> (); q.<span class="built_in">pop</span> ();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">            <span class="type">int</span> t = es[i].v;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> es[i].flow) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (dep[t] != <span class="number">0x3f3f3f3f</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">            dep[t] = dep[now] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span> (t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dep[T] != <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> now, <span class="type">long</span> <span class="type">long</span> now_flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now == T <span class="keyword">or</span> <span class="keyword">not</span> now_flow) &#123; <span class="keyword">return</span> now_flow; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[now]; i; i = es[i].pre) &#123;</span><br><span class="line">        <span class="type">int</span> t = es[i].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> es[i].flow) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep[t] != dep[now] + <span class="number">1</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t_flow = <span class="built_in">dfs</span> (t, std::<span class="built_in">min</span> (now_flow, es[i].flow));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t_flow) &#123;</span><br><span class="line">            es[i].flow -= t_flow;</span><br><span class="line">            es[i ^ <span class="number">1</span>].flow += t_flow;</span><br><span class="line">            now_flow -= t_flow;</span><br><span class="line">            res += t_flow;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> now_flow) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Dinic</span> <span class="params">(<span class="type">int</span> _s, <span class="type">int</span> <span class="type">_t</span>)</span> </span>&#123;</span><br><span class="line">    S = _s, T = <span class="type">_t</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span> ()) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span> (cur, last, <span class="built_in">sizeof</span> (last));</span><br><span class="line">        res += <span class="built_in">dfs</span> (S, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="网络单纯形"><a href="#网络单纯形" class="headerlink" title="网络单纯形"></a>网络单纯形</h4><p>把之前写的代码粘过来了</p>
<p>码风可能有点不太一样</p>
<p>而且好像使用 $\text{LCT}$ 实现会更容易一些…</p>
<p><del>然而我学网络单纯形的时候并不会lct</del></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NetworkSimplex &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		<span class="type">int</span> pre;</span><br><span class="line">		<span class="type">int</span> flow;</span><br><span class="line">		<span class="type">int</span> cost;</span><br><span class="line">	&#125; es[maxm];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> last[maxn], cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _addEdge (<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap, <span class="type">int</span> cost) &#123;</span><br><span class="line">		es[++cnt] = Edge &#123; u, v, last[u], cap, cost &#125;;</span><br><span class="line">		last[u] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap, <span class="type">int</span> cost)</span> </span>&#123;</span><br><span class="line">		_addEdge (u, v, cap, cost);</span><br><span class="line">		_addEdge (v, u, <span class="number">0</span>, -cost);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fa[maxn], faEdge[maxn]; <span class="comment">// fa[u] : u的父亲 | faEdge[u] : 父亲指向u的边</span></span><br><span class="line">	<span class="type">int</span> mark[maxn], curTime = <span class="number">1</span>; <span class="comment">// mark[u] : 节点u的时间戳 | curTime : 当前时间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先找出基解 (随便找一棵生成树)</span></span><br><span class="line">	<span class="comment">// 此时mark的作用是标记是否访问过</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initTree</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">			<span class="type">int</span> t = es[i].v;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">not</span> es[i].flow) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (mark[t]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			mark[t] = <span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">			fa[t] = now;</span><br><span class="line">			faEdge[t] = i;</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">initTree</span> (t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> piCache[maxn]; <span class="comment">// 缓存一下pi优化</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pi</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="comment">// 当前节点到根节点的代价和</span></span><br><span class="line">		<span class="keyword">if</span> (mark[now] == curTime) &#123; <span class="keyword">return</span> piCache[now]; &#125; <span class="comment">// 当前节点的时间戳是当前时间 (piCache里的东西没有过时), 直接返回</span></span><br><span class="line">		mark[now] = curTime; <span class="comment">// 当前点经过更新已经是最新的了</span></span><br><span class="line">		<span class="keyword">return</span> piCache[now] = es[faEdge[now]].cost + <span class="built_in">pi</span>(fa[now]); <span class="comment">// 当前点的pi是从根节点到父亲的代价 + 父亲到当前点的代价</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">pushFlow</span> <span class="params">(<span class="type">int</span> eid)</span> </span>&#123; <span class="comment">// 沿着给定非树边的编号eid形成的环推流</span></span><br><span class="line">		++curTime; <span class="comment">// 时间戳增加</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 找根</span></span><br><span class="line">		<span class="type">int</span> root = es[eid].u;</span><br><span class="line">		<span class="keyword">while</span> (root) &#123; mark[root] = curTime; root = fa[root]; &#125; <span class="comment">// 向上跳并在跳的路径上打标记</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找lca</span></span><br><span class="line">		<span class="type">int</span> lca = es[eid].v;</span><br><span class="line">		<span class="keyword">while</span> (mark[lca] != curTime) &#123; mark[lca] = curTime; lca = fa[lca]; &#125; <span class="comment">// 向上跳, 一直跳到被标记过 (也就是说要跳到在u到根的路径上),, 显然第一个跳到的点是lca</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找出基的边 (流量最小的边)</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> minFlow = es[eid].flow; <span class="comment">// 能流的流量 (最小的流量)</span></span><br><span class="line">		<span class="type">int</span> delNode = <span class="number">0</span>; <span class="comment">// 被删去的边的对应点</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">2</span>; <span class="comment">// flag = 2 : 没找到 (当前边就是) | 0 : 在lca到u的路径上 | 1 : 在v到lca的路径上</span></span><br><span class="line">		std::vector &lt;<span class="type">int</span>&gt; circle; <span class="comment">// 存环上的边</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从u向上找lca往u方向的流量最小的边</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> now = es[eid].u; now != lca; now = fa[now]) &#123;</span><br><span class="line">			<span class="type">int</span> nowEdge = faEdge[now]; <span class="comment">// 因为是lca往u方向流所以是u的父亲到u的边</span></span><br><span class="line">			circle.<span class="built_in">push_back</span> (nowEdge);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (minFlow &gt; es[nowEdge].flow) &#123;</span><br><span class="line">				minFlow = es[nowEdge].flow;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				delNode = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从v想上找v往lca方向的流量最小的边</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> now = es[eid].v; now != lca; now = fa[now]) &#123;</span><br><span class="line">			<span class="type">int</span> nowEdge = faEdge[now] ^ <span class="number">1</span>; <span class="comment">// 因为是v往lca方向流所以是v到父亲的边</span></span><br><span class="line">			circle.<span class="built_in">push_back</span> (nowEdge);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (minFlow &gt; es[nowEdge].flow) &#123;</span><br><span class="line">				minFlow = es[nowEdge].flow;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				delNode = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		circle.<span class="built_in">push_back</span> (eid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给环上每个边增加流量并统计费用</span></span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> cost = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> now : circle) &#123;</span><br><span class="line">			es[now].flow -= minFlow;</span><br><span class="line">			es[now ^ <span class="number">1</span>].flow += minFlow;</span><br><span class="line">			cost += minFlow * es[now].cost;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">2</span>) &#123; <span class="keyword">return</span> cost; &#125; <span class="comment">// 最小边是当前边, 不许要改变树的结构</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 改变树的结构 (加入入基边, 删除出基边)</span></span><br><span class="line">		<span class="comment">// 实际上就是翻转树的结构 (此处我们直接暴力翻转)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果最小边是在lca到u的路径上, 我们实际上要对v-&gt;u-&gt;delNode的路径进行更新; </span></span><br><span class="line">		<span class="comment">// 如果最小边是在v到lca的路径上, 我们实际上要对u-&gt;v-&gt;delNode的路径进行更新</span></span><br><span class="line">		<span class="comment">// 这里有一个trick</span></span><br><span class="line">		<span class="comment">// 我们发现, 在第一种情况里的u-&gt;delNode和第二种情况里v-&gt;delNode的路径中, 我们原有的faEdge[x]都是从我们要跳到的点, 指向当前点x</span></span><br><span class="line">		<span class="comment">// 如果我们能统一边的方向(从我们要跳到的点指向当前点), 翻转整条链的操作就会变得非常好处理</span></span><br><span class="line">		<span class="comment">// 然后我们又发现</span></span><br><span class="line">		<span class="comment">// 第一种情况里u-&gt;v的这条边恰好满足从我们要跳到的点u到我们当前的点v这一条件</span></span><br><span class="line">		<span class="comment">// 第二种情况正好相反</span></span><br><span class="line">		<span class="comment">// 所以第二种情况下, 我们先对我们要加入的这条边u-&gt;v翻转一下, 取他的反向边v-&gt;u</span></span><br><span class="line">		<span class="comment">// 这样就可以统一处理了</span></span><br><span class="line"></span><br><span class="line">		eid = eid ^ flag; <span class="comment">// 所以我们直接异或上flag (如果在lca到u的路径上, flag就等于0, 异或上0等于没有异或)</span></span><br><span class="line">		<span class="type">int</span> u = es[eid].u;</span><br><span class="line">		<span class="type">int</span> v = es[eid].v;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> lastNode = v; <span class="comment">// 上一个操作的点</span></span><br><span class="line">		<span class="type">int</span> lastEdge = eid; <span class="comment">// 上一个边</span></span><br><span class="line">		<span class="type">int</span> nextNode = <span class="number">0</span>; <span class="comment">// 下一个点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> now = u; lastNode != delNode; now = nextNode) &#123;</span><br><span class="line">			nextNode = fa[now];</span><br><span class="line">			mark[now] --; <span class="comment">// 信息过期, 时间戳--</span></span><br><span class="line"></span><br><span class="line">			lastEdge ^= <span class="number">1</span>; <span class="comment">// 将上一条边翻转</span></span><br><span class="line">			<span class="built_in">swap</span> (lastEdge, faEdge[now]);</span><br><span class="line">			</span><br><span class="line">			fa[now] = lastNode;</span><br><span class="line">			lastNode = now;		</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> cost;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MCMF</span> &#123;</span><br><span class="line">		<span class="type">int</span> minCost, maxFlow;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> MCMF <span class="title">simplex</span> <span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">addEdge</span> (T, S, inf, -inf); <span class="comment">// 加这条辅助边保证最大流</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">initTree</span> (T); <span class="comment">// 寻找基解</span></span><br><span class="line">		mark[T] = ++curTime;</span><br><span class="line">		fa[T] = <span class="number">0</span>; <span class="comment">// 钦定T是根</span></span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> cost = <span class="number">0</span>; <span class="comment">// 由于一开始加了一条费用为-inf的边, 费用可能很大, 最好开long long</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (es[i].flow <span class="keyword">and</span> es[i].cost + <span class="built_in">pi</span>(es[i].u) - <span class="built_in">pi</span>(es[i].v) &lt; <span class="number">0</span>) &#123; <span class="comment">// 寻找可以形成负环的边</span></span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">					cost += <span class="built_in">pushFlow</span> (i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">not</span> flag) &#123; <span class="keyword">break</span>; &#125; <span class="comment">// 没有找到可以形成负环推流的边, 停止</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 最后加上的边反向边 (S -&gt; T) 的flow就是我们的最大流</span></span><br><span class="line">		<span class="comment">// (因为我们这条边加的意义是使得任意S到T的流都可以与它形成负环, 所以每次推流的时候都会把增加的流量加到它上面去)</span></span><br><span class="line">		<span class="type">int</span> maxFlow = es[cnt].flow; </span><br><span class="line">		<span class="type">int</span> minCost = <span class="built_in">int</span> ((<span class="type">long</span> <span class="type">long</span>) es[cnt].flow * inf + cost); <span class="comment">// 需要加上 es[cnt].flow * inf 抵消掉一开始那条边的费用  </span></span><br><span class="line">		<span class="keyword">return</span> MCMF &#123; minCost, maxFlow &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span> (mark, <span class="number">0</span>, <span class="built_in">sizeof</span>(mark)); curTime = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span> (piCache, <span class="number">0</span>, <span class="built_in">sizeof</span>(piCache));</span><br><span class="line">		<span class="built_in">memset</span> (last, <span class="number">0</span>, <span class="built_in">sizeof</span>(last)); cnt = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>啥也不会</p>
<h3 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> ch[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> fa;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    &#125; ns[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last, root, tot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加信息</span></span><br><span class="line">    i64 cnt[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAM</span> () &#123; last = root = tot = <span class="number">1</span>; <span class="built_in">memset</span> (cnt, <span class="number">0</span>, <span class="built_in">sizeof</span> (cnt)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = last;</span><br><span class="line">        <span class="type">int</span> np = last = ++tot;</span><br><span class="line"></span><br><span class="line">        ns[np].len = ns[p].len + <span class="number">1</span>;</span><br><span class="line">        cnt[np] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; p <span class="keyword">and</span> <span class="keyword">not</span> ns[p].ch[c]; p = ns[p].fa) &#123; ns[p].ch[c] = np; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> p) &#123; ns[np].fa = root; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> q = ns[p].ch[c];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ns[q].len == ns[p].len + <span class="number">1</span>) &#123; ns[np].fa = q; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> nq = ++tot;</span><br><span class="line">                ns[nq] = ns[q]; ns[nq].len = ns[p].len + <span class="number">1</span>;</span><br><span class="line">                ns[q].fa = ns[np].fa = nq;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (; p <span class="keyword">and</span> ns[p].ch[c] == q; p = ns[p].fa) &#123; ns[p].ch[c] = nq; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getParentTree</span> <span class="params">(Graph&amp; tr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i++) &#123; tr.<span class="built_in">addEdge</span> (ns[i].fa, i); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="回文自动机"><a href="#回文自动机" class="headerlink" title="回文自动机"></a>回文自动机</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Palindrome_Automaton &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">		<span class="type">int</span> len, cnt;</span><br><span class="line">		<span class="type">int</span> next[<span class="number">26</span>];</span><br><span class="line">		<span class="type">int</span> fail;</span><br><span class="line">	&#125;;</span><br><span class="line">	Node pam[maxn];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cnt, last;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		cnt = <span class="number">1</span>, last = <span class="number">0</span>; <span class="comment">// 奇根的前一个是偶根</span></span><br><span class="line">		pam[<span class="number">0</span>].len = <span class="number">0</span>;</span><br><span class="line">		pam[<span class="number">1</span>].len = <span class="number">-1</span>; <span class="comment">// 两边同时加入一个</span></span><br><span class="line">		pam[<span class="number">0</span>].fail = <span class="number">1</span>; <span class="comment">// 奇根不会有fail </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decrypt (x) 只是为了满足模板题里面的强制在线而已</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> decrypt(x) (s[i] + pam[last].cnt - 97) % 26 + 97</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> get_fail(x) while (s[i] != s[i - pam[x].len - 1]) &#123; x = pam[x].fail; &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123; s[i] = <span class="built_in">decrypt</span>(i); &#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> a = last; <span class="built_in">get_fail</span>(a);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">not</span> pam[a].next[s[i] - <span class="string">&#x27;a&#x27;</span>]) &#123; <span class="comment">// 没有就新建节点</span></span><br><span class="line">				<span class="type">int</span> b = pam[a].fail; <span class="built_in">get_fail</span>(b);</span><br><span class="line">				</span><br><span class="line">				cnt ++;</span><br><span class="line">				pam[cnt].fail = pam[b].next[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">				pam[cnt].cnt = pam[pam[cnt].fail].cnt + <span class="number">1</span>;</span><br><span class="line">				pam[cnt].len = pam[a].len + <span class="number">2</span>;</span><br><span class="line">				pam[a].next[s[i] - <span class="string">&#x27;a&#x27;</span>] = cnt;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			last = pam[a].next[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">			res.<span class="built_in">push_back</span>(pam[last].cnt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">ksm</span> <span class="params">(i64 a, i64 b, i64 mod)</span> </span>&#123;</span><br><span class="line">    i64 res = <span class="number">1</span>;</span><br><span class="line">    i64 base = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123; (res *= base) %= mod; &#125;</span><br><span class="line">        (base *= base) %= mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">phi</span> <span class="params">(i64 n)</span> </span>&#123;</span><br><span class="line">    i64 ans = n;</span><br><span class="line">    <span class="keyword">for</span> (i64 p = <span class="number">2</span>; p * p &lt;= n; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % p != <span class="number">0</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        ans = ans / p * (p - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % p == <span class="number">0</span>) &#123; n /= p; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123; ans = ans / n * (n - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>这里使用欧拉函数求逆元</p>
<p><del>不会写exgcd导致的</del></p>
<p>你说的对, 但是 $a ^ {\varphi(b)} &#x3D; 1 \pmod b$</p>
<p>所以我们可以直接求逆元</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">inv</span> <span class="params">(i64 a, i64 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Ksm::<span class="built_in">ksm</span> (a, <span class="built_in">phi</span> (b) - <span class="number">1</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">exgcd</span> <span class="params">(i64 a, i64 b, i64 &amp;x, i64 &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    i64 d = <span class="built_in">exgcd</span> (b, a % b, y, x);</span><br><span class="line">    y -= x * (a / b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>于是, 上面的逆元也可以用exgcd求</p>
<p>因为 </p>
<p>$$<br>a \times inv_a \equiv 1 \pmod b \</p>
<p>a \times inv_a + b \times y &#x3D; 0<br>$$</p>
<p>所以我们很容易用exgcd求出 $inv_a$</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> i64 <span class="title">inv</span> <span class="params">(i64 a, i64 b)</span> </span>&#123;</span><br><span class="line">    i64 x, y; <span class="built_in">exgcd</span> (a, b, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x + b) % b;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;maxn&gt; not_prime;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_primes</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    not_prime.<span class="built_in">reset</span> ();</span><br><span class="line">    not_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> not_prime[i]) &#123; primes.<span class="built_in">push_back</span> (i); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">            not_prime[i * p] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="筛莫比乌斯函数"><a href="#筛莫比乌斯函数" class="headerlink" title="筛莫比乌斯函数"></a>筛莫比乌斯函数</h4><p>用线性筛筛出莫比乌斯函数</p>
<p>顺便求出前缀和</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_mu</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    not_prime.<span class="built_in">reset</span> ();</span><br><span class="line">    <span class="type">int</span> n = maxn - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    not_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> not_prime[i]) &#123; primes.<span class="built_in">push_back</span> (i); mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">            not_prime[i * p] = <span class="literal">true</span>;</span><br><span class="line">            mu[i * p] = <span class="number">-1</span> * mu[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) &#123; mu[i * p] = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; sum[i] = sum[i - <span class="number">1</span>] + mu[i]; &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></div>

<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>只会大数翻倍法</p>
<p><del>所以这其实是假的中国剩余定理</del></p>
<p><del>orz钟神太强了%%%</del></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">merge</span> <span class="params">(i64 &amp;m1, i64 &amp;a1, i64 m2, i64 a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m1 &lt; m2) &#123; std::<span class="built_in">swap</span> (m1, m2); std::<span class="built_in">swap</span> (a1, a2); &#125;           </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a1 % m2 != a2) &#123; a1 += m1; &#125;</span><br><span class="line"></span><br><span class="line">    m1 = <span class="built_in">lcm</span> (m1, m2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><del>真的超级好写啊啊啊</del></p>
<h4 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h4><p>不用害怕, zhx的大数翻倍法本身就能合并两个同余方程</p>
<p>所以合并部分代码跟上面一样</p>
<h3 id="高维前缀和"><a href="#高维前缀和" class="headerlink" title="高维前缀和"></a>高维前缀和</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; <span class="number">22</span>); S++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i)) &#123; sum[S] = sum[S] + sum[S ^ (<span class="number">1</span> &lt;&lt; i)]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></div>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> maxn&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionFindSet</span> &#123;</span><br><span class="line">    <span class="type">int</span> fa[maxn];  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; fa[i] = i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x] == x) &#123; <span class="keyword">return</span> fa[x]; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> fa[x] = <span class="built_in">find</span> (fa[x]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[<span class="built_in">find</span> (y)] = <span class="built_in">find</span> (x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">same</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span> (x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> maxsiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    <span class="type">int</span> tr[maxsiz];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123; tr[i] += val; &#125; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> _query (<span class="type">int</span> pos) &#123; <span class="type">int</span> res = <span class="number">0</span>;<span class="keyword">for</span> (<span class="type">int</span> i = pos; i; i -= <span class="built_in">lowbit</span>(i)) &#123; res += tr[i]; &#125; <span class="keyword">return</span> res; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> _query (r) - _query (l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>上面只给出了单点加区间求和的版本</p>
<p>实际上, 树状数组还可以通过神秘的技术实现区间加单点查和 <strong>区间加区间求和</strong></p>
<p>甚至可以通过跳 <code>lowbit</code> 实现 <strong>区间最值查询</strong></p>
<p>然而实现十分复杂, 失去了树状数组本身简洁的优势</p>
<p><del>而且复杂度好像也不是很对</del> (曾被hzhl狠狠质疑)</p>
<p>所以不如写线段树 👇</p>
</blockquote>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> maxn, <span class="keyword">typename</span> <span class="type">val_t</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">val_t</span> sum;</span><br><span class="line">        <span class="type">val_t</span> tag; <span class="type">bool</span> cov;</span><br><span class="line">    &#125; tr[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushUp</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">        tr[now].sum = tr[now &lt;&lt; <span class="number">1</span>].sum + tr[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        tr[now].sum += val * (r - l + <span class="number">1</span>);</span><br><span class="line">        tr[now].tag += val;</span><br><span class="line">        tr[now].cov = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushDown</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> tr[now].cov) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">update</span> (now &lt;&lt; <span class="number">1</span>, l, mid, tr[now].tag);</span><br><span class="line">        <span class="built_in">update</span> (now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tr[now].tag);</span><br><span class="line">        tr[now].tag = <span class="number">0</span>; tr[now].cov = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tr[now] = Node &#123; a[l], <span class="number">0</span>, <span class="literal">false</span> &#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span> (now &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span> (now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pushUp</span> (now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l <span class="keyword">and</span> r &lt;= R) &#123; <span class="built_in">update</span> (now, l, r, val); <span class="keyword">return</span>; &#125; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">pushDown</span> (now, l, r);</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mid) &#123; <span class="built_in">modify</span> (now &lt;&lt; <span class="number">1</span>, l, mid, L, R, val); &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; mid) &#123; <span class="built_in">modify</span> (now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, val); &#125;</span><br><span class="line">        <span class="built_in">pushUp</span> (now);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">val_t</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l <span class="keyword">and</span> r &lt;= R) &#123; <span class="keyword">return</span> tr[now].sum; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pushDown</span> (now, l, r);</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">val_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mid) &#123; res += <span class="built_in">query</span> (now &lt;&lt; <span class="number">1</span>, l, mid, L, R); &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; mid) &#123; res += <span class="built_in">query</span> (now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>使用的时候, 只需要 <code>SegmentTree&lt;maxn, i64&gt; tr</code> 就行</p>
</blockquote>
<h4 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h4><p>其实是动态开点线段树</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> maxn, <span class="keyword">typename</span> <span class="type">val_t</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> lson, rson;</span><br><span class="line">        <span class="type">val_t</span> sum;</span><br><span class="line">    &#125; tr[maxn &lt;&lt; <span class="number">4</span> + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tot;</span><br><span class="line">    <span class="built_in">SegmentTree</span> () &#123; tot = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushUp</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; tr[now].sum = tr[tr[now].lson].sum + tr[tr[now].rson].sum; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span> &amp;now, <span class="type">val_t</span> l, <span class="type">val_t</span> r, <span class="type">val_t</span> pos, <span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> now) &#123; now = ++tot; &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; tr[now].sum += val; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">val_t</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) &#123; <span class="built_in">modify</span> (tr[now].lson, l, mid, pos, val); &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid) &#123; <span class="built_in">modify</span> (tr[now].rson, mid + <span class="number">1</span>, r, pos, val); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pushUp</span> (now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">val_t</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> now, <span class="type">val_t</span> l, <span class="type">val_t</span> r, <span class="type">val_t</span> L, <span class="type">val_t</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> now) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l <span class="keyword">and</span> r &lt;= R) &#123; <span class="keyword">return</span> tr[now].sum; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">val_t</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">val_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mid) &#123; res += <span class="built_in">query</span> (tr[now].lson, l, mid, L, R); &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; mid) &#123; res += <span class="built_in">query</span> (tr[now].rson, mid + <span class="number">1</span>, r, L, R); &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h4><h5 id="可持久化数组"><a href="#可持久化数组" class="headerlink" title="可持久化数组"></a>可持久化数组</h5><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> maxn, <span class="keyword">typename</span> <span class="type">val_t</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PresistentArray</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> ls, rs;</span><br><span class="line">        <span class="type">val_t</span> val;</span><br><span class="line">    &#125; tr[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tot, root[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span> <span class="params">(Node old = Node &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;)</span> </span>&#123; tr[++tot] = old; <span class="keyword">return</span> tot; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        now = <span class="built_in">newNode</span> ();</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; tr[now].val = a[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span> (tr[now].ls, l, mid);</span><br><span class="line">        <span class="built_in">build</span> (tr[now].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> old, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        now = <span class="built_in">newNode</span> (tr[old]);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; tr[now].val = val; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) &#123; <span class="built_in">modify</span> (tr[now].ls, tr[old].ls, l, mid, pos, val); &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid) &#123; <span class="built_in">modify</span> (tr[now].rs, tr[old].rs, mid + <span class="number">1</span>, r, pos, val); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">val_t</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> now) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; <span class="keyword">return</span> tr[now].val; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) &#123; <span class="keyword">return</span> <span class="built_in">query</span> (tr[now].ls, l, mid, pos); &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid) &#123; <span class="keyword">return</span> <span class="built_in">query</span> (tr[now].rs, mid + <span class="number">1</span>, r, pos); &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="01-trie"><a href="#01-trie" class="headerlink" title="01-trie"></a>01-trie</h3><h4 id="可删除元素-01-trie"><a href="#可删除元素-01-trie" class="headerlink" title="可删除元素 01-trie"></a>可删除元素 01-trie</h4><p>其实就是普通 01-trie</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    i64 tr[maxn &lt;&lt; <span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> tot;</span><br><span class="line">    <span class="type">int</span> siz[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(i64 val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">bool</span> x = ((val &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> tr[now][x]) &#123; tr[now][x] = ++tot; &#125;</span><br><span class="line">            now = tr[now][x];</span><br><span class="line">            siz[now]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span> <span class="params">(i64 val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">bool</span> x = ((val &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">            now = tr[now][x];</span><br><span class="line">            siz[now]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">i64 <span class="title">query</span> <span class="params">(i64 val)</span> </span>&#123; <span class="comment">// 使得结果尽可能小</span></span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">        i64 ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">bool</span> x = ((val &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> siz[tr[now][x]]) &#123; ans |= (<span class="number">1ll</span> &lt;&lt; i); now = tr[now][x ^ <span class="number">1</span>]; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; now = tr[now][x]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; trie;</span><br></pre></td></tr></table></figure></div>

<h4 id="查询-k-大-01-trie"><a href="#查询-k-大-01-trie" class="headerlink" title="查询 k 大 01-trie"></a>查询 k 大 01-trie</h4><p>与平衡树很像</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">	<span class="type">int</span> tr[maxn &lt;&lt; <span class="number">5</span>][<span class="number">2</span>], tot, root;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> siz[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Trie</span> () &#123; tot = <span class="number">0</span>; root = ++tot; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span> <span class="params">(i64 val)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> now = root; siz[now] ++;</span><br><span class="line">		<span class="keyword">for</span> (i64 i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="type">bool</span> x = ((val &gt;&gt; i) &amp; <span class="number">1ll</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">not</span> tr[now][x]) &#123; tr[now][x] = ++tot; &#125;</span><br><span class="line">			now = tr[now][x];</span><br><span class="line">			</span><br><span class="line">			siz[now] ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> i64 <span class="title">query</span> <span class="params">(i64 val, <span class="type">int</span> rnk)</span> </span>&#123;</span><br><span class="line">		i64 res = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> now = root;</span><br><span class="line">		<span class="keyword">for</span> (i64 i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="type">bool</span> x = ((val &gt;&gt; i) &amp; <span class="number">1ll</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">not</span> tr[now][x ^ <span class="number">1</span>]) &#123; now = tr[now][x]; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (rnk &lt;= siz[tr[now][x ^ <span class="number">1</span>]]) &#123;</span><br><span class="line">				res |= <span class="number">1ll</span> &lt;&lt; i;</span><br><span class="line">				now = tr[now][x ^ <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				rnk -= siz[tr[now][x ^ <span class="number">1</span>]];</span><br><span class="line">				now = tr[now][x];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; trie;</span><br></pre></td></tr></table></figure></div>

<h4 id="可持久化-01-trie"><a href="#可持久化-01-trie" class="headerlink" title="可持久化 01-trie"></a>可持久化 01-trie</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">	<span class="type">int</span> tr[maxn &lt;&lt; <span class="number">6</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> tot;</span><br><span class="line">	<span class="type">int</span> siz[maxn &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> rt[maxn];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123; tr[i][<span class="number">0</span>] = tr[i][<span class="number">1</span>] = <span class="number">0</span>; siz[i] = <span class="number">0</span>; &#125; </span><br><span class="line">		tot = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> old, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="type">bool</span> x = ((val &gt;&gt; i) &amp; <span class="number">1</span>);	</span><br><span class="line">			</span><br><span class="line">			tr[now][x] = ++tot; tr[now][x ^ <span class="number">1</span>] = tr[old][x ^ <span class="number">1</span>];  <span class="comment">// clone</span></span><br><span class="line">			</span><br><span class="line">			now = tr[now][x]; old = tr[old][x];</span><br><span class="line">			</span><br><span class="line">			siz[now] = siz[old] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> old, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="type">bool</span> x = ((val &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (siz[tr[now][x ^ <span class="number">1</span>]] - siz[tr[old][x ^ <span class="number">1</span>]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				now = tr[now][x ^ <span class="number">1</span>]; old = tr[old][x ^ <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				now = tr[now][x]; old = tr[old][x];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; trie;</span><br></pre></td></tr></table></figure></div>

<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><h4 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ-Treap"></a>FHQ-Treap</h4><h5 id="普通平衡树"><a href="#普通平衡树" class="headerlink" title="普通平衡树"></a>普通平衡树</h5><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> maxn, <span class="keyword">typename</span> <span class="type">val_t</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FhqTreap</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> ls, rs;</span><br><span class="line">        <span class="type">val_t</span> val;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> key;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">    &#125; tr[maxn];</span><br><span class="line"></span><br><span class="line">    std::mt19937 rnd;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tot, root;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        tr[++tot] = Node &#123; <span class="number">0</span>, <span class="number">0</span>, val, <span class="built_in">rnd</span> (), <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; tr[now].size = tr[tr[now].ls].size + tr[tr[now].rs].size + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FhqTreap</span> () &#123; tot = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span> <span class="params">(<span class="type">int</span> now, <span class="type">val_t</span> val, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> now) &#123;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tr[now].val &lt;= val) &#123;</span><br><span class="line">            x = now; <span class="built_in">split</span> (tr[now].rs, val, tr[now].rs, y);</span><br><span class="line">            <span class="built_in">update</span> (x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y = now; <span class="built_in">split</span> (tr[now].ls, val, x, tr[now].ls);</span><br><span class="line">            <span class="built_in">update</span> (y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x | y;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tr[x].key &lt; tr[y].key) &#123;</span><br><span class="line">            tr[x].rs = <span class="built_in">merge</span> (tr[x].rs, y);</span><br><span class="line">            <span class="built_in">update</span> (x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr[y].ls = <span class="built_in">merge</span> (x, tr[y].ls);</span><br><span class="line">            <span class="built_in">update</span> (y);</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span> <span class="params">(<span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y; <span class="built_in">split</span> (root, val, x, y);</span><br><span class="line">        root = <span class="built_in">merge</span> (<span class="built_in">merge</span> (x, <span class="built_in">newNode</span> (val)), y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">remove</span> <span class="params">(<span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">split</span> (root, val, x, y);</span><br><span class="line">        <span class="built_in">split</span> (x, val - <span class="number">1</span>, x, z);</span><br><span class="line">        z = <span class="built_in">merge</span> (tr[z].ls, tr[z].rs);</span><br><span class="line">        root = <span class="built_in">merge</span> (<span class="built_in">merge</span> (x, z), y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">val_t</span> <span class="title">pre</span> <span class="params">(<span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y; <span class="built_in">split</span> (root, val - <span class="number">1</span>, x, y);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> now = x;</span><br><span class="line">        <span class="keyword">while</span> (tr[now].rs) &#123; now = tr[now].rs; &#125;</span><br><span class="line">        </span><br><span class="line">        root = <span class="built_in">merge</span> (x, y);</span><br><span class="line">        <span class="keyword">return</span> tr[now].val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">val_t</span> <span class="title">nxt</span> <span class="params">(<span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y; <span class="built_in">split</span> (root, val, x, y);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> now = y;</span><br><span class="line">        <span class="keyword">while</span> (tr[now].ls) &#123; now = tr[now].ls; &#125;</span><br><span class="line"></span><br><span class="line">        root = <span class="built_in">merge</span> (x, y);</span><br><span class="line">        <span class="keyword">return</span> tr[now].val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_rank</span> <span class="params">(<span class="type">val_t</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y; <span class="built_in">split</span> (root, val - <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="type">int</span> rank = tr[x].size + <span class="number">1</span>;</span><br><span class="line">        root = <span class="built_in">merge</span> (x, y);</span><br><span class="line">        <span class="keyword">return</span> rank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">val_t</span> <span class="title">get_val</span> <span class="params">(<span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[tr[now].ls].size + <span class="number">1</span> == rank) &#123; <span class="keyword">return</span> tr[now].val; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tr[tr[now].ls].size &gt;= rank) &#123; now = tr[now].ls; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; rank -= tr[tr[now].ls].size + <span class="number">1</span>; now = tr[now].rs; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="文艺平衡树"><a href="#文艺平衡树" class="headerlink" title="文艺平衡树"></a>文艺平衡树</h5><p>其实就是维护中序遍历</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> ls, rs;</span><br><span class="line">	<span class="type">int</span> siz;</span><br><span class="line">	<span class="type">bool</span> tag;</span><br><span class="line"></span><br><span class="line">	i64 key;</span><br><span class="line">&#125; tr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root, tot;</span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span> <span class="params">(std::chrono::steady_clock::now ().time_since_epoch ().count ())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	tr[++tot] = Node &#123; val, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="built_in">rnd</span> () &#125;;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushUp</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	tr[now].siz = tr[tr[now].ls].siz + tr[tr[now].rs].siz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushDown</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tr[now].tag) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span> (tr[now].ls, tr[now].rs);</span><br><span class="line">		tr[tr[now].ls].tag ^= <span class="number">1</span>; tr[tr[now].rs].tag ^= <span class="number">1</span>;</span><br><span class="line">		tr[now].tag = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> siz, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">not</span> now) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="built_in">pushDown</span> (now);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (siz &lt;= tr[tr[now].ls].siz) &#123;</span><br><span class="line">		y = now; <span class="built_in">split</span> (tr[now].ls, siz, x, tr[now].ls);</span><br><span class="line">		<span class="built_in">pushUp</span> (now);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = now; <span class="built_in">split</span> (tr[now].rs, siz - tr[tr[now].ls].siz - <span class="number">1</span>, tr[now].rs, y);</span><br><span class="line">		<span class="built_in">pushUp</span> (now);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y) &#123; <span class="keyword">return</span> x | y; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tr[x].key &lt; tr[y].key) &#123;</span><br><span class="line">		<span class="built_in">pushDown</span> (x);</span><br><span class="line">		tr[x].rs = <span class="built_in">merge</span> (tr[x].rs, y);</span><br><span class="line">		<span class="built_in">pushUp</span> (x);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">pushDown</span> (y);</span><br><span class="line">		tr[y].ls = <span class="built_in">merge</span> (x, tr[y].ls);</span><br><span class="line">		<span class="built_in">pushUp</span> (y);</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rev</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y, z;</span><br><span class="line">	<span class="built_in">split</span> (root, r, x, z);</span><br><span class="line">	<span class="built_in">split</span> (x, l - <span class="number">1</span>, x, y);</span><br><span class="line">	tr[y].tag ^= <span class="number">1</span>;</span><br><span class="line">	root = <span class="built_in">merge</span> (<span class="built_in">merge</span> (x, y), z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">not</span> now) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pushDown</span> (now);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">output</span> (tr[now].ls);</span><br><span class="line">	std::cout &lt;&lt; tr[now].val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">output</span> (tr[now].rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="可持久化平衡树"><a href="#可持久化平衡树" class="headerlink" title="可持久化平衡树"></a>可持久化平衡树</h5><p>其实跟可持久化线段树本质相同</p>
<p>似乎算导上讲过数据结构可持久化的通用方法</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> ls, rs;</span><br><span class="line">	<span class="type">int</span> siz;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> key;</span><br><span class="line">&#125; tr[maxn * <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span> <span class="params">(std::chrono::steady_clock::now ().time_since_epoch ().count ())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, root[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span> <span class="params">(Node old)</span> </span>&#123;</span><br><span class="line">	tr[++tot] = old;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushUp</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; tr[now].siz = tr[tr[now].ls].siz + tr[tr[now].rs].siz + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> val, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">not</span> now) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tr[now].val &lt;= val) &#123;</span><br><span class="line">		<span class="type">int</span> id = <span class="built_in">newNode</span> (tr[now]);</span><br><span class="line">		x = id; <span class="built_in">split</span> (tr[id].rs, val, tr[id].rs, y);</span><br><span class="line">		<span class="built_in">pushUp</span> (id);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> id = <span class="built_in">newNode</span> (tr[now]);</span><br><span class="line">		y = id; <span class="built_in">split</span> (tr[id].ls, val, x, tr[id].ls);</span><br><span class="line">		<span class="built_in">pushUp</span> (id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y) &#123; <span class="keyword">return</span> x | y; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tr[x].key &lt;= tr[y].key) &#123;</span><br><span class="line">		<span class="type">int</span> id = <span class="built_in">newNode</span> (tr[x]);</span><br><span class="line">		tr[id].rs = <span class="built_in">merge</span> (tr[id].rs, y);</span><br><span class="line">		<span class="built_in">pushUp</span> (id);</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> id = <span class="built_in">newNode</span> (tr[y]);</span><br><span class="line">		tr[id].ls = <span class="built_in">merge</span> (x, tr[id].ls);</span><br><span class="line">		<span class="built_in">pushUp</span> (id);</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span> <span class="params">(<span class="type">int</span> val, <span class="type">int</span> i, <span class="type">int</span> old)</span> </span>&#123;</span><br><span class="line">	root[i] = root[old];</span><br><span class="line">	<span class="type">int</span> x, y; <span class="built_in">split</span> (root[i], val, x, y);</span><br><span class="line">	root[i] = <span class="built_in">merge</span> (<span class="built_in">merge</span> (x, <span class="built_in">newNode</span> (&#123; val, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="built_in">rnd</span> () &#125;)), y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">remove</span> <span class="params">(<span class="type">int</span> val, <span class="type">int</span> i, <span class="type">int</span> old)</span> </span>&#123;</span><br><span class="line">	root[i] = root[old];</span><br><span class="line">	<span class="type">int</span> x, y; <span class="built_in">split</span> (root[i], val, x, y);</span><br><span class="line">	<span class="type">int</span> z; <span class="built_in">split</span> (x, val - <span class="number">1</span>, x, z);</span><br><span class="line">	z = <span class="built_in">merge</span> (tr[z].ls, tr[z].rs);</span><br><span class="line">	root[i] = <span class="built_in">merge</span> (<span class="built_in">merge</span> (x, z), y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getRank</span> <span class="params">(<span class="type">int</span> val, <span class="type">int</span> i, <span class="type">int</span> old)</span> </span>&#123;</span><br><span class="line">	root[i] = root[old];</span><br><span class="line">	<span class="type">int</span> x, y; <span class="built_in">split</span> (root[i], val - <span class="number">1</span>, x, y);</span><br><span class="line">	<span class="type">int</span> rank = tr[x].siz + <span class="number">1</span>;</span><br><span class="line">	root[i] = <span class="built_in">merge</span> (x, y);</span><br><span class="line">	<span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getNum</span> <span class="params">(<span class="type">int</span> rank, <span class="type">int</span> i, <span class="type">int</span> old)</span> </span>&#123;</span><br><span class="line">	root[i] = root[old];</span><br><span class="line">	<span class="type">int</span> now = root[i];</span><br><span class="line">	<span class="keyword">while</span> (now) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tr[tr[now].ls].siz + <span class="number">1</span> == rank) &#123; <span class="keyword">return</span> tr[now].val; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rank &lt;= tr[tr[now].ls].siz) &#123; now = tr[now].ls; &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; rank -= tr[tr[now].ls].siz + <span class="number">1</span>; now = tr[now].rs; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pre</span> <span class="params">(<span class="type">int</span> val, <span class="type">int</span> i, <span class="type">int</span> old)</span> </span>&#123;</span><br><span class="line">	root[i] = root[old];</span><br><span class="line">	<span class="type">int</span> x, y; <span class="built_in">split</span> (root[i], val - <span class="number">1</span>, x, y);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> now = x;</span><br><span class="line">	<span class="keyword">while</span> (tr[now].rs) &#123; now = tr[now].rs; &#125;</span><br><span class="line">	root[i] = <span class="built_in">merge</span> (x, y);</span><br><span class="line">	<span class="keyword">return</span> now ? tr[now].val : <span class="number">-2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nxt</span> <span class="params">(<span class="type">int</span> val, <span class="type">int</span> i, <span class="type">int</span> old)</span> </span>&#123;</span><br><span class="line">	root[i] = root[old];</span><br><span class="line">	<span class="type">int</span> x, y; <span class="built_in">split</span> (root[i], val, x, y);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> now = y;</span><br><span class="line">	<span class="keyword">while</span> (tr[now].ls) &#123; now = tr[now].ls; &#125;</span><br><span class="line">	root[i] = <span class="built_in">merge</span> (x, y);</span><br><span class="line">	<span class="keyword">return</span> now ? tr[now].val : <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h3><h4 id="树状数组套线段树"><a href="#树状数组套线段树" class="headerlink" title="树状数组套线段树"></a>树状数组套线段树</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FenwickTree</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">			<span class="type">int</span> ls, rs;</span><br><span class="line">			<span class="type">int</span> sum;</span><br><span class="line">		&#125; tr[maxn &lt;&lt; <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; Add;</span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; Sub;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> root[maxn], tot;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span>&amp; now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">not</span> now) &#123; now = ++tot; &#125;</span><br><span class="line">			tr[now].sum += val;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (l == r) &#123; <span class="keyword">return</span>; &#125;	</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pos &lt;= mid) &#123; <span class="built_in">modify</span> (tr[now].ls, l, mid, pos, val); &#125;</span><br><span class="line">			<span class="keyword">if</span> (pos &gt; mid) &#123; <span class="built_in">modify</span> (tr[now].rs, mid + <span class="number">1</span>, r, pos, val); &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l == r) &#123; <span class="keyword">return</span> l; &#125;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> sum = <span class="number">0</span>; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : Add) &#123; sum += tr[tr[x].ls].sum; &#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : Sub) &#123; sum -= tr[tr[x].ls].sum; &#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : Add) &#123; x = (k &lt;= sum) ? tr[x].ls : tr[x].rs; &#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : Sub) &#123; x = (k &lt;= sum) ? tr[x].ls : tr[x].rs; &#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> (k &lt;= sum) ? <span class="built_in">query</span> (l, mid, k) : <span class="built_in">query</span> (mid + <span class="number">1</span>, r, k - sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; seg;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span> <span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; i += <span class="built_in">lowbit</span> (i)) &#123; seg.<span class="built_in">modify</span> (seg.root[i], <span class="number">0</span>, <span class="number">1e9</span>, val, <span class="number">1</span>); &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span> <span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; i += <span class="built_in">lowbit</span> (i)) &#123; seg.<span class="built_in">modify</span> (seg.root[i], <span class="number">0</span>, <span class="number">1e9</span>, val, <span class="number">-1</span>); &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		seg.Add.<span class="built_in">clear</span> (); <span class="keyword">for</span> (<span class="type">int</span> i = r; i; i -= <span class="built_in">lowbit</span> (i)) &#123; seg.Add.<span class="built_in">push_back</span> (seg.root[i]); &#125;</span><br><span class="line">		seg.Sub.<span class="built_in">clear</span> (); <span class="keyword">for</span> (<span class="type">int</span> i = l - <span class="number">1</span>; i; i -= <span class="built_in">lowbit</span> (i)) &#123; seg.Sub.<span class="built_in">push_back</span> (seg.root[i]); &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> seg.<span class="built_in">query</span> (<span class="number">0</span>, <span class="number">1e9</span>, k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; tr;</span><br></pre></td></tr></table></figure></div>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><p>核心部分代码不长</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[maxn], siz[maxn], son[maxn], dep[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	siz[now] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">		<span class="type">int</span> t = es[i].v;</span><br><span class="line">		<span class="keyword">if</span> (t == fa[now]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		fa[t] = now;</span><br><span class="line">		dep[t] = dep[now] + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build_tree</span> (t);</span><br><span class="line">		siz[now] += siz[t];</span><br><span class="line">		<span class="keyword">if</span> (siz[t] &gt; siz[son[now]]) &#123; son[now] = t; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top[maxn], dfn[maxn], dpos, rnk[maxn];</span><br><span class="line"><span class="comment">// int bottom[maxn];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_decomp</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> topnow)</span> </span>&#123;</span><br><span class="line">	dfn[now] = ++dpos;</span><br><span class="line">	rnk[dfn[now]] = now;</span><br><span class="line">	top[now] = topnow;</span><br><span class="line">	<span class="comment">// bottom[now] = dfn[now];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">not</span> son[now]) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="built_in">tree_decomp</span> (son[now], topnow);</span><br><span class="line">	<span class="comment">// bottom[now] = std::max (bottom[now], bottom[son[now]]);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">		<span class="type">int</span> t = es[i].v;</span><br><span class="line">		<span class="keyword">if</span> (t == fa[now]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (t == son[now]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">tree_decomp</span> (t, t);</span><br><span class="line">		<span class="comment">// bottom[now] = std::max (bottom[now], bottom[t]);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="子树内的信息"><a href="#子树内的信息" class="headerlink" title="子树内的信息"></a>子树内的信息</h4><p>一般会像上面注释里面一样维护一个 <code>bottom[u]</code> 表示以 $u$ 为根的子树中最大的 $dfn$</p>
<p>然后就可以</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> i64 <span class="title">subtreeQuery</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tr.<span class="built_in">query</span> (<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], bottom[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>修改同理</p>
<h4 id="路径上的信息"><a href="#路径上的信息" class="headerlink" title="路径上的信息"></a>路径上的信息</h4><p>直接跳链即可</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chainModify</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, i64 val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]]) &#123;</span><br><span class="line">			tr.<span class="built_in">modify</span> (<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x], val);</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tr.<span class="built_in">modify</span> (<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[y]], dfn[y], val);</span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x] &gt; dfn[y]) &#123; std::<span class="built_in">swap</span> (x, y); &#125;</span><br><span class="line">	tr.<span class="built_in">modify</span> (<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[y], val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>查询同理</p>
<h4 id="lca"><a href="#lca" class="headerlink" title="lca"></a>lca</h4><p>同样是直接跳链</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">			u = fa[top[u]];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			v = fa[top[v]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Link-Cut-Tree"><a href="#Link-Cut-Tree" class="headerlink" title="Link-Cut Tree"></a>Link-Cut Tree</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> sum, val;</span><br><span class="line">	<span class="type">int</span> ch[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> fa;</span><br><span class="line">	<span class="type">bool</span> tag;</span><br><span class="line">&#125; tr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">chk</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now == tr[tr[now].fa].ch[<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">notRoot</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now == tr[tr[now].fa].ch[<span class="number">0</span>] <span class="keyword">or</span> now == tr[tr[now].fa].ch[<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushUp</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; tr[now].sum = tr[tr[now].ch[<span class="number">0</span>]].sum <span class="keyword">xor</span> tr[tr[now].ch[<span class="number">1</span>]].sum <span class="keyword">xor</span> tr[now].val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rev</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123; std::<span class="built_in">swap</span> (tr[now].ch[<span class="number">0</span>], tr[now].ch[<span class="number">1</span>]); tr[now].tag ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushDown</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">not</span> tr[now].tag) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (tr[now].ch[<span class="number">0</span>]) &#123; <span class="built_in">rev</span> (tr[now].ch[<span class="number">0</span>]); &#125;</span><br><span class="line">	<span class="keyword">if</span> (tr[now].ch[<span class="number">1</span>]) &#123; <span class="built_in">rev</span> (tr[now].ch[<span class="number">1</span>]); &#125;</span><br><span class="line">	tr[now].tag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushAll</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">notRoot</span> (now)) &#123; <span class="built_in">pushAll</span> (tr[now].fa); &#125;</span><br><span class="line">	<span class="built_in">pushDown</span> (now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> fa, <span class="type">int</span> x, <span class="type">int</span> p)</span> </span>&#123; tr[fa].ch[p] = x; tr[x].fa = fa; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> f = tr[x].fa, ff = tr[f].fa, p = <span class="built_in">chk</span> (x), pp = <span class="built_in">chk</span> (f); </span><br><span class="line">	<span class="built_in">pushDown</span> (f); <span class="built_in">pushDown</span> (x);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">notRoot</span> (f)) &#123; <span class="built_in">connect</span> (ff, x, pp); &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; tr[x].fa = ff; &#125;</span><br><span class="line">	<span class="built_in">connect</span> (f, tr[x].ch[p ^ <span class="number">1</span>], p); <span class="built_in">connect</span> (x, f, p ^ <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushUp</span> (f); <span class="built_in">pushUp</span> (x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">pushAll</span> (x);</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">notRoot</span> (x); <span class="built_in">rotate</span> (x)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">notRoot</span> (tr[x].fa)) &#123; <span class="built_in">rotate</span> (<span class="built_in">chk</span> (tr[x].fa) == <span class="built_in">chk</span> (x) ? tr[x].fa : x); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushUp</span> (x);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		<span class="built_in">splay</span> (x); tr[x].ch[<span class="number">1</span>] = pre; <span class="built_in">pushUp</span> (x);</span><br><span class="line">		x = tr[pre = x].fa;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makeRoot</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="built_in">access</span> (x); <span class="built_in">splay</span> (x); <span class="built_in">rev</span> (x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="built_in">makeRoot</span> (x); <span class="built_in">access</span> (y); <span class="built_in">splay</span> (y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findRoot</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">access</span> (x); <span class="built_in">splay</span> (x); </span><br><span class="line">    <span class="built_in">pushDown</span> (x); <span class="keyword">while</span> (tr[x].ch[<span class="number">0</span>]) &#123; x = tr[x].ch[<span class="number">0</span>]; <span class="built_in">pushDown</span> (x); &#125;</span><br><span class="line">	<span class="built_in">splay</span> (x); <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; </span><br><span class="line">	<span class="built_in">makeRoot</span> (x); </span><br><span class="line">	<span class="keyword">if</span> (x == <span class="built_in">findRoot</span> (y)) &#123; <span class="keyword">return</span>; &#125; </span><br><span class="line">	tr[x].fa = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; </span><br><span class="line">	<span class="built_in">split</span> (x, y); </span><br><span class="line">	<span class="keyword">if</span> (tr[y].ch[<span class="number">0</span>] != x <span class="keyword">or</span> tr[x].ch[<span class="number">0</span>] != tr[x].ch[<span class="number">1</span>]) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	tr[y].ch[<span class="number">0</span>] = tr[x].fa = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">pushUp</span> (y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><p><del>淀粉质</del></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	es[++cnt] = Edge &#123; u, v, last[u], w &#125;;</span><br><span class="line">	last[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line">std::bitset&lt;maxn&gt; removed;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="type">int</span> maxpart[maxn];</span><br><span class="line"><span class="type">int</span> siz[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRoot</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	siz[now] = <span class="number">1</span>; </span><br><span class="line">	maxpart[now] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">		<span class="type">int</span> t = es[i].v;</span><br><span class="line">		<span class="keyword">if</span> (t == fa) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (removed[t])	&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">getRoot</span> (t, now);</span><br><span class="line">		siz[now] += siz[t];</span><br><span class="line">		maxpart[now] = std::<span class="built_in">max</span> (maxpart[now], siz[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	maxpart[now] = std::<span class="built_in">max</span> (maxpart[now], sum - siz[now]);</span><br><span class="line">	<span class="keyword">if</span> (maxpart[now] &lt; maxpart[root]) &#123; root = now; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> disStack[maxn], dpos;</span><br><span class="line"><span class="type">int</span> removeStack[maxn], rpos;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getDis</span> <span class="params">(<span class="type">int</span> now, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	disStack[++dpos] = dis[now];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">		<span class="type">int</span> t = es[i].v;</span><br><span class="line">		<span class="keyword">if</span> (t == fa) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (removed[t]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		</span><br><span class="line">		dis[t] = dis[now] + es[i].w;</span><br><span class="line">		<span class="built_in">getDis</span> (t, now);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxv = <span class="number">100000005</span>;</span><br><span class="line">std::bitset&lt;maxv&gt; exist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	exist[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">		<span class="type">int</span> t = es[i].v;</span><br><span class="line">		<span class="keyword">if</span> (removed[t]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">		dis[t] = es[i].w;</span><br><span class="line">		<span class="built_in">getDis</span> (t, now);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= dpos; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q : qs) &#123;</span><br><span class="line">				<span class="keyword">if</span> (q.k - disStack[j] &gt;= <span class="number">0</span>) &#123; q.ans |= exist[q.k - disStack[j]]; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (dpos) &#123;</span><br><span class="line">			<span class="type">int</span> top = disStack[dpos--];</span><br><span class="line">			exist[top] = <span class="literal">true</span>;</span><br><span class="line">			removeStack[++rpos] = top;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (rpos) &#123;</span><br><span class="line">		<span class="type">int</span> top = removeStack[rpos--];</span><br><span class="line">		exist[top] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">divide</span> <span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	removed[now] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">solve</span> (now);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = last[now]; i; i = es[i].pre) &#123;</span><br><span class="line">		<span class="type">int</span> t = es[i].v;</span><br><span class="line">		<span class="keyword">if</span> (removed[t]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">		sum = siz[t];</span><br><span class="line">		maxpart[root] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">		<span class="built_in">getRoot</span> (t, now);</span><br><span class="line">		<span class="built_in">getRoot</span> (root, now); <span class="comment">// 实际上在getSiz</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">divide</span> (root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> 蒟蒻の模板</li>
        <li><strong>作者:</strong> rainbow-auto</li>
        <li><strong>创建于
                :</strong> 2023-10-02 22:01:54</li>
        
            <li>
                <strong>更新于
                    :</strong> 2024-08-26 22:03:18
            </li>
        
        <li>
            <strong>链接:</strong> https://rainbow-auto.github.io/2023/10/02/蒟蒻の模板/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

            </div>
        

        

        

        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">蒟蒻の模板</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%92%9F%E8%92%BB-Rainbow-Automaton-%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-text">蒟蒻 Rainbow-Automaton 的模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">代码注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%8B%8D"><span class="nav-text">对拍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%AB%E7%A7%92%E7%BA%A7%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">毫秒级随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6"><span class="nav-text">计时</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%9B%BE"><span class="nav-text">存图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-text">最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="nav-text">欧拉回路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tarjan-%E7%B3%BB%E5%88%97"><span class="nav-text">Tarjan 系列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-text">网络流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-text">后缀自动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-text">回文自动机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-text">欧拉函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%85%83"><span class="nav-text">逆元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exgcd"><span class="nav-text">exgcd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B"><span class="nav-text">线性筛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="nav-text">中国剩余定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-text">高维前缀和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="nav-text">树状数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-trie"><span class="nav-text">01-trie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-text">平衡树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%A5%97%E6%A0%91"><span class="nav-text">树套树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="nav-text">树链剖分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Link-Cut-Tree"><span class="nav-text">Link-Cut Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="nav-text">点分治</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">rainbow-auto</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共 1 篇文章
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.4</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
